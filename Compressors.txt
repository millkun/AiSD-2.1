#include <iostream>
#include <string>
#include <queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <algorithm>
#include <tuple>
#include <sstream>
#include <cstring>
#include <memory>
#include <functional>
#include <map>
#include <stdexcept>
#include <iterator>
#include <cstdint>
#include <numeric>

using namespace std;

// ----------------------------------- HA [Huffman Algorithm] -----------------------------------

struct Node {
    int frequency; // Собственно частота
    string old_code; // Символ
    Node* left; // Указатели на левый и правый ветки узла
    Node* right;

    Node(int freq, string code = "", Node* l = nullptr, Node* r = nullptr)
        : frequency(freq), old_code(code), left(l), right(r) {
    }
};

struct CompareNodes {
    bool operator()(Node* a, Node* b) {
        return a->frequency > b->frequency;
    }
};

class HATree {
public:
    Node* root;
    map<int, string> codes;

    HATree() : root(nullptr) {}

    void buildTree(const vector<int>& frequencies) {
        priority_queue<Node*, vector<Node*>, CompareNodes> nodes;

        for (int i = 0; i < 256; ++i) {
            if (frequencies[i] > 0) {
                nodes.push(new Node(frequencies[i], to_string(i)));
            }
        }

        while (nodes.size() > 1) {
            Node* left = nodes.top();
            nodes.pop();
            Node* right = nodes.top();
            nodes.pop();

            Node* merged = new Node(left->frequency + right->frequency, "", left, right);
            nodes.push(merged);
        }

        if (!nodes.empty()) {
            root = nodes.top();
            generate_codes(root, "");
        }
    }

    void generate_codes(Node* node, const string& prefix) {
        if (!node) return;
        if (!node->left && !node->right) {
            codes[stoi(node->old_code)] = prefix;
        }
        generate_codes(node->left, prefix + "0");
        generate_codes(node->right, prefix + "1");
    }

    ~HATree() {
        delete_tree(root);
    }

private:
    void delete_tree(Node* node) {
        if (node) {
            delete_tree(node->left);
            delete_tree(node->right);
            delete node;
        }
    }
};

vector<int> countBytes(const vector<unsigned char>& data) {
    vector<int> frequencies(256, 0);
    for (unsigned char byte : data) {
        frequencies[byte]++;
    }
    return frequencies;
}

vector<unsigned char> haEncoder(const vector<unsigned char>& data) {
    vector<int> frequencies = countBytes(data);
    HATree tree;
    tree.buildTree(frequencies);

    string encoded_bits;
    for (unsigned char byte : data) {
        encoded_bits += tree.codes[byte];
    }
    int bit_length = encoded_bits.size();

    vector<unsigned char> header;
    for (int i = 0; i < 4; ++i) {
        header.push_back((bit_length >> (i * 8)) & 0xFF); // По 8 бит сдвигаю число и через объединение с 
    }                                                     // 0xFF маскирую то, что не нужно

    int symbolTable = count_if(frequencies.begin(), frequencies.end(), [](int f) { return f > 0; });
    for (int i = 0; i < 4; ++i) {
        header.push_back((symbolTable >> (i * 8)) & 0xFF);
    }

    for (int byte = 0; byte < 256; ++byte) {
        if (frequencies[byte] > 0) {
            header.push_back(byte);
            for (int i = 0; i < 4; ++i) {
                header.push_back((frequencies[byte] >> (i * 8)) & 0xFF);
            }
        }
    }

    int padded_length = ((bit_length + 7) / 8) * 8; // Дополняю битовую строку до длины, кратной 8 битам,
    encoded_bits.resize(padded_length, '0'); // чтобы можно было разбить на байты для правильной записи в файл

    for (size_t i = 0; i < encoded_bits.size(); i += 8) {
        string byte_str = encoded_bits.substr(i, 8);
        unsigned char byte = static_cast<unsigned char>(bitset<8>(byte_str).to_ulong());
        header.push_back(byte);
    }

    return header;
}

vector<unsigned char> haDecoder(const vector<unsigned char>& encoded_data) {
    if (encoded_data.size() < 8) { // Закодированные данные имеют минимум 8 байт [bit_length и symbolTable]
        throw runtime_error("Invalid encoded data: too short"); // Иначе файл будет битым, это важная инфа в начале
    }

    int bit_length = 0;
    for (int i = 0; i < 4; ++i) {
        bit_length |= encoded_data[i] << (i * 8); // Собираю сдвигами по 8 бит
    }

    int symbolTable = 0; // По-другому назвать надо было, переименовал
    for (int i = 4; i < 8; ++i) {
        symbolTable |= encoded_data[i] << ((i - 4) * 8); // По 8 бит сдвигаю также
    }

    vector<int> frequencies(256, 0);
    size_t pos = 8;
    for (int i = 0; i < symbolTable; ++i) {
        if (pos + 5 > encoded_data.size()) {
            throw runtime_error("Invalid encoded data");
        }
        unsigned char byte = encoded_data[pos++];
        int freq = 0;
        for (int j = 0; j < 4; ++j) {
            freq |= encoded_data[pos++] << (j * 8);
        }
        frequencies[byte] = freq;
    }

    HATree tree;
    tree.buildTree(frequencies);
    map<string, int> reverse_codes;
    for (const auto& pair : tree.codes) {
        reverse_codes[pair.second] = pair.first;
    }

    string encoded_bits;
    for (size_t i = pos; i < encoded_data.size(); ++i) {
        encoded_bits += bitset<8>(encoded_data[i]).to_string();
    }
    encoded_bits.resize(bit_length);

    vector<unsigned char> decoded;
    string current_code;
    for (char bit : encoded_bits) {
        current_code += bit;
        if (reverse_codes.find(current_code) != reverse_codes.end()) {
            decoded.push_back(static_cast<unsigned char>(reverse_codes[current_code]));
            current_code.clear();
        }
    }

    return decoded;
}

void compressHA(const string& inputFile) {
    ifstream inFile(inputFile, ios::binary);
    if (!inFile) {
        cerr << "Error opening input file: " << inputFile << endl;
        return;
    }

    vector<unsigned char> data((istreambuf_iterator<char>(inFile)),
        istreambuf_iterator<char>());
    inFile.close();

    vector<unsigned char> compressed = haEncoder(data);

    ofstream outFile("compressed-HA.bin", ios::binary);
    if (!outFile) {
        cerr << "Error creating output file: compressed-HA.bin" << endl;
        return;
    }

    outFile.write(reinterpret_cast<const char*>(compressed.data()), compressed.size());
    outFile.close();

    cout << "Compression completed:" << endl;
    cout << " - Compressed size: " << compressed.size() << " bytes" << endl;
}

void decompressHA(const string& inputFile) {
    ifstream inFile(inputFile, ios::binary);
    if (!inFile) {
        cerr << "Error opening input file: " << inputFile << endl;
        return;
    }

    streamsize compressedSize = inFile.tellg();
    inFile.seekg(0, ios::beg);

    vector<unsigned char> data((istreambuf_iterator<char>(inFile)),
        istreambuf_iterator<char>());
    inFile.close();

    vector<unsigned char> decompressed = haDecoder(data);

    ofstream outFile("decompressed-HA.txt", ios::binary);
    if (!outFile) {
        cerr << "Error creating output file: decompressed-HA.txt" << endl;
        return;
    }

    outFile.write(reinterpret_cast<const char*>(decompressed.data()), decompressed.size());
    outFile.close();

    cout << "Decompression completed:" << endl;
    cout << " - Decompressed size: " << decompressed.size() << " bytes" << endl;
}

// ----------------------------------- RLE [Run-Length Encoding] -----------------------------------

vector<char> readFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file.is_open()) throw runtime_error("Cannot open file: " + filename);

    file.seekg(0, ios::end); // Определяю размер файла
    size_t fileSize = file.tellg();
    file.seekg(0, ios::beg);

    vector<char> buffer(fileSize);
    if (fileSize > 0) file.read(buffer.data(), fileSize); // Всё содержимое в вектор char
    return buffer;
}

void writeFile(const string& filename, const vector<char>& data) {
    ofstream file(filename, ios::binary);
    if (!file.is_open()) throw runtime_error("Cannot create file: " + filename);
    if (!data.empty()) file.write(data.data(), data.size());
}

vector<char> compressRLE(const vector<char>& input) {
    vector<char> compressed;
    if (input.empty()) return compressed;

    size_t i = 0;
    const size_t n = input.size();

    while (i < n) {
        char current = input[i];
        size_t count = 1;

        // Считаю повторы
        while (i + count < n && input[i + count] == current && count < 127) {
            count++;
        }

        if (count > 1) { // Для повторяющихся символов 
            compressed.push_back(static_cast<char>(count));
            compressed.push_back(current);
            i += count;
        }
        else {
            // Тут считаю неповторяющиеся последовательности
            size_t unique_count = 0; // Для них использую отрицательные числа, это удобно
            while (i + unique_count < n && // Соответственно у меня только 127 символов может быть в одном блоке
                (i + unique_count + 1 >= n || input[i + unique_count] != input[i + unique_count + 1]) &&
                unique_count < 127) { 
                unique_count++;
            }

            if (unique_count == 0) unique_count = 1; // Защита от бесконечного цикла

            compressed.push_back(static_cast<char>(-static_cast<signed char>(unique_count)));
            for (size_t j = 0; j < unique_count && i + j < n; j++) {
                compressed.push_back(input[i + j]);
            }
            i += unique_count;
        }
    }

    return compressed;
}

vector<char> decompressRLE(const vector<char>& compressed) {
    vector<char> decompressed;
    if (compressed.empty()) return decompressed;

    size_t i = 0;
    const size_t n = compressed.size();

    while (i < n) {
        signed char count = static_cast<signed char>(compressed[i]);

        if (count > 0) {
            // Обработка повторяющихся символов
            if (i + 1 >= n) break; // Недостаточно данных
            char value = compressed[i + 1];
            for (int j = 0; j < count; j++) { // Повторяю столько, сколько надо
                decompressed.push_back(value);
            }
            i += 2;
        }
        else {
            // Обработка неповтор. символов. Просто копирую последовательность
            int unique_count = -count;
            if (i + unique_count >= n) break; // Недостаточно данных

            for (int j = 1; j <= unique_count && i + j < n; j++) {
                decompressed.push_back(compressed[i + j]);
            }
            i += 1 + unique_count;
        }
    }

    return decompressed;
}

void compressRLE(const string& inputFile) {
    try {
        cout << "Reading file: " << inputFile << endl;
        vector<char> inputData = readFile(inputFile);
        cout << "File size: " << inputData.size() << " bytes" << endl;

        vector<char> compressedData = compressRLE(inputData);
        writeFile("compressed-RLE.bin", compressedData);

        cout << "RLE compression successful. Compressed size: "
            << compressedData.size() << " bytes (ratio: "
            << (inputData.empty() ? 0 : (double)compressedData.size() / inputData.size() * 100)
            << "%)" << endl;
    }
    catch (const exception& e) {
        cerr << "Error during RLE compression: " << e.what() << endl;
    }
}

void decompressRLE(const string& inputFile) {
    try {
        cout << "Reading compressed file: " << inputFile << endl;
        vector<char> compressedData = readFile(inputFile);
        cout << "Compressed size: " << compressedData.size() << " bytes" << endl;

        vector<char> decompressedData = decompressRLE(compressedData);
        writeFile("decompressed-RLE.txt", decompressedData);

        cout << "RLE decompression successful. Decompressed size: "
            << decompressedData.size() << " bytes" << endl;
    }
    catch (const exception& e) {
        cerr << "Error during RLE decompression: " << e.what() << endl;
    }
}

// ----------------------------------- BWT [Burrows–Wheeler Transform] -----------------------------------

vector<uint8_t> bwtTransform(const vector<uint8_t>& block, int& index) {
    int n = block.size();
    if (n == 0) { // Проверка пустого блока
        index = 0; // index будет хранить позицию исходной строки в отсортированных вращениях
        return {};
    }

    vector<int> indices(n);
    iota(indices.begin(), indices.end(), 0); // Заполнил вектор последовательными значениями от 0 до n-1

    sort(indices.begin(), indices.end(), [&block, n](int a, int b) {
        for (int i = 0; i < n; ++i) { // Сортирую индексы на основе лексикографического порядка всех циклических вращений
            uint8_t ca = block[(a + i) % n]; // Для сравнения двух вращений просматриваю все символы по кругу (% n)
            uint8_t cb = block[(b + i) % n];
            if (ca != cb) return ca < cb; // Сравниваю вращения символов
        }
        return false;
    });

    auto it = find(indices.begin(), indices.end(), 0); // позицию исходной строки (индекс 0) в отсортированном 
    index = distance(indices.begin(), it); // списке вращений. Понадобится для обратного BWT

    vector<uint8_t> transformed;
    transformed.reserve(n);
    for (int i : indices) {
        transformed.push_back(block[(i + n - 1) % n]); // Берём последний символ с каждого вращения
    }

    return transformed;
}

vector<uint8_t> bwtInverse(const vector<uint8_t>& transformed, int index) { // index - это позиция исходной строки
    int n = transformed.size(); // Собственно размер преобразованных данных
    if (n == 0) return {};

    vector<pair<uint8_t, int>> table; // Создаю таблицу, где каждый элемент это пара из символа и исходного индекса
    table.reserve(n);
    for (int i = 0; i < n; ++i) {
        table.emplace_back(transformed[i], i);
    }

    stable_sort(table.begin(), table.end(), // Сортировочка
        [](const pair<uint8_t, int>& a, const pair<uint8_t, int>& b) {
        return a.first < b.first;
    });

    vector<int> T(n);
    for (int i = 0; i < n; ++i) {
        T[table[i].second] = i; // T[i] показывает, куда перемещается символ из позиции i после сортировки
    }

    vector<uint8_t> original;
    original.reserve(n);
    int current = index; // Начинаю с index и на каждом шаге добавляю символ и перехожу по T
    for (int i = 0; i < n; ++i) {
        original.push_back(transformed[current]); // На выходе исходные данные, но в обратном порядке
        current = T[current];
    }

    reverse(original.begin(), original.end()); // Тут восстанавливаю порядок
    return original;
}

void compressBWT(const string& input_file, int block_size = 1024) {
    if (block_size <= 0) {
        throw invalid_argument("Block size must be positive");
    }

    ifstream input(input_file, ios::binary);
    ofstream output("compressed-BWT.bin", ios::binary);

    if (!input) throw runtime_error("Cannot open input file: " + input_file);
    if (!output) throw runtime_error("Cannot open output file: compressed-BWT.bin");

    vector<uint8_t> block(block_size);

    while (true) {
        input.read(reinterpret_cast<char*>(block.data()), block_size);
        streamsize bytes_read = input.gcount();
        if (bytes_read == 0) break;

        int index;
        vector<uint8_t> transformed = bwtTransform(vector<uint8_t>(block.begin(), block.begin() + bytes_read), index);

        int32_t index32 = static_cast<int32_t>(index);
        int32_t size32 = static_cast<int32_t>(transformed.size());

        output.write(reinterpret_cast<const char*>(&index32), sizeof(index32));
        output.write(reinterpret_cast<const char*>(&size32), sizeof(size32));
        output.write(reinterpret_cast<const char*>(transformed.data()), transformed.size());
    }
}

void decompressBWT(const string& input_file) {
    ifstream input(input_file, ios::binary);
    ofstream output("decompressed-BWT.txt", ios::binary);

    if (!input) throw runtime_error("Cannot open input file: " + input_file);
    if (!output) throw runtime_error("Cannot open output file: decompressed-BWT.txt");

    input.seekg(0, ios::end);
    streampos compressed_size = input.tellg();
    input.seekg(0, ios::beg);
    cout << "Compressed file size: " << compressed_size << " bytes" << endl;

    while (true) {
        int32_t index32;
        input.read(reinterpret_cast<char*>(&index32), sizeof(index32));
        if (input.eof()) break;
        if (input.fail()) throw runtime_error("Failed to read block index");

        int32_t size32;
        input.read(reinterpret_cast<char*>(&size32), sizeof(size32));
        if (input.fail()) throw runtime_error("Failed to read block size");

        if (size32 <= 0) throw runtime_error("Invalid block size");

        vector<uint8_t> transformed(size32);
        input.read(reinterpret_cast<char*>(transformed.data()), size32);
        if (input.gcount() != size32) throw runtime_error("Truncated block data");

        vector<uint8_t> original = bwtInverse(transformed, index32);
        output.write(reinterpret_cast<const char*>(original.data()), original.size());
        if (output.fail()) throw runtime_error("Failed to write decompressed data");
    }

    output.close();
    ifstream output_check("decompressed-BWT.txt", ios::binary | ios::ate);
    cout << "Decompressed file size: " << output_check.tellg() << " bytes" << endl;
    output_check.close();
}

// ----------------------------------- LZ77 [Lempel-Ziv 1977] -----------------------------------

struct Token {
    uint16_t offset;  // расстояние до начала найденного совпадения в окне
    uint8_t length;   // длина совпадения
    char next;        // следующий символ после совпадения
    bool isLast;      // если true, то токен завершающий и поле next не используется
};

vector<Token> dataCompressLZ77(const string& input, int windowSize = 4096, int lookaheadBufferSize = 16) {
    vector<Token> tokens;
    size_t i = 0;
    while (i < input.size()) {
        int bestLength = 0;
        int bestOffset = 0;
        int start = (i >= windowSize) ? i - windowSize : 0; // Тернарные операторы классная штука. Заметка: использовать в будущих проектах, уменьшает запись
        for (int j = start; j < i; j++) {
            int length = 0;
            while (length < lookaheadBufferSize && i + length < input.size() && // Не вышли за размеры буфера,
                input[j + length] == input[i + length]) { // не превысили размер строки и символы в окне и буфере совпадают
                length++;
            }
            if (length > bestLength) {
                bestLength = length;
                bestOffset = i - j;
            }
        }
        Token token;
        if (i + bestLength < input.size()) {
            token.offset = (bestLength > 0) ? bestOffset : 0;
            token.length = bestLength;
            token.next = input[i + bestLength];
            token.isLast = false;
            tokens.push_back(token);
            i += bestLength + 1;
        }
        else {
            token.offset = (bestLength > 0) ? bestOffset : 0;
            token.length = bestLength;
            token.next = 0;
            token.isLast = true;
            tokens.push_back(token);
            i += bestLength;
        }
    }
    return tokens;
}

string dataDecompressLZ77(const vector<Token>& tokens) {
    string output;
    for (const auto& token : tokens) {
        if (token.length > 0) {
            int pos = output.size() - token.offset;
            for (int i = 0; i < token.length; i++) {
                output.push_back(output[pos + i]);
            }
        }
        if (!token.isLast) {
            output.push_back(token.next);
        }
    }
    return output;
}

void compressLZ77(const string& inputFile) {
    ifstream in(inputFile, ios::binary);
    if (!in) {
        cerr << "Не удалось открыть входной файл " << inputFile << "\n";
        return;
    }
    string inputData((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();

    int windowSize = 4096; // 8192 пробовал, гавно
    int lookaheadBufferSize = 64; // 16 было

    vector<Token> tokens = dataCompressLZ77(inputData, windowSize, lookaheadBufferSize);

    ofstream out("compressed-LZ77.bin", ios::binary);
    if (!out) {
        cerr << "Не удалось создать файл compressed-LZ77.bin\n";
        return;
    }
    uint32_t tokenCount = tokens.size();
    out.write(reinterpret_cast<const char*>(&tokenCount), sizeof(tokenCount));
    for (const auto& token : tokens) {
        out.write(reinterpret_cast<const char*>(&token.offset), sizeof(token.offset));
        out.write(reinterpret_cast<const char*>(&token.length), sizeof(token.length));
        out.write(&token.next, sizeof(token.next));
        out.write(reinterpret_cast<const char*>(&token.isLast), sizeof(token.isLast));
    }
    out.close();

    ifstream original(inputFile, ios::binary | ios::ate);
    ifstream compressed("compressed-LZ77.bin", ios::binary | ios::ate);
    cout << "LZ77 compression results:\n";
    cout << "Original size: " << original.tellg() << " bytes\n";
    cout << "Compressed size: " << compressed.tellg() << " bytes\n";
    cout << "Compression ratio: " << (float)original.tellg() / compressed.tellg() << "\n";
}

void decompressLZ77(const string& inputFile) {
    ifstream inCompressed(inputFile, ios::binary);
    if (!inCompressed) {
        cerr << "Не удалось открыть файл " << inputFile << "\n";
        return;
    }
    uint32_t tokenCount;
    inCompressed.read(reinterpret_cast<char*>(&tokenCount), sizeof(tokenCount));
    vector<Token> tokens(tokenCount);
    for (uint32_t i = 0; i < tokenCount; i++) {
        Token token;
        inCompressed.read(reinterpret_cast<char*>(&token.offset), sizeof(token.offset));
        inCompressed.read(reinterpret_cast<char*>(&token.length), sizeof(token.length));
        inCompressed.read(&token.next, sizeof(token.next));
        inCompressed.read(reinterpret_cast<char*>(&token.isLast), sizeof(token.isLast));
        tokens[i] = token;
    }
    inCompressed.close();

    string decompressedData = dataDecompressLZ77(tokens);

    ofstream out("decompressed-LZ77.txt", ios::binary);
    if (!out) {
        cerr << "Не удалось создать файл decompressed-LZ77.txt\n";
        return;
    }
    out.write(decompressedData.data(), decompressedData.size());
    out.close();

    // Вывод информации о распаковке
    ifstream compressed(inputFile, ios::binary | ios::ate);
    ifstream decompressed("decompressed-LZ77.txt", ios::binary | ios::ate);
    cout << "LZ77 decompression results:\n";
    cout << "Compressed size: " << compressed.tellg() << " bytes\n";
    cout << "Decompressed size: " << decompressed.tellg() << " bytes\n";
}

// ----------------------------------- LZW [Lempel-Ziv-Welch] -----------------------------------

const int MAX_DICT_SIZE = 4096; // Максимальный размер словаря

void compressLZW(const string& inputFile) {
    ifstream inFile(inputFile, ios::binary);
    ofstream outFile("compressed-LZW.bin", ios::binary);

    if (!inFile.is_open() || !outFile.is_open()) {
        cerr << "Error opening files!" << endl;
        return;
    }

    unordered_map<string, int> dictionary; // Создал начальный словарь со всеми возможными байтами
    for (int i = 0; i < 256; i++) { // Ключи - это строки из одного символа. Значения - это их коды от 0 до 255
        dictionary[string(1, char(i))] = i;
    }

    string current = ""; // Алгритм находит самую длинную строку, которая есть в словаре
    int dictSize = 256;
    vector<int> output;

    char byte;
    while (inFile.get(byte)) {
        string next = current + byte; // Когда строка current + byte отсутствует в словаре, то выводится код
        if (dictionary.count(next)) { // для current, новая строка добавляется в словарь и обработка
            current = next; // начинается с byte
        }
        else {
            output.push_back(dictionary[current]);
            if (dictSize < MAX_DICT_SIZE) {
                dictionary[next] = dictSize++;
            }
            current = string(1, byte);
        }
    }

    if (!current.empty()) {
        output.push_back(dictionary[current]);
    }

    for (int code : output) {
        outFile.write(reinterpret_cast<const char*>(&code), sizeof(code));
    }

    inFile.close();
    outFile.close();

    ifstream original(inputFile, ios::binary | ios::ate);
    ifstream compressed("compressed-LZW.bin", ios::binary | ios::ate);
    cout << "LZW compression results:\n";
    cout << "Original size: " << original.tellg() << " bytes\n";
    cout << "Compressed size: " << compressed.tellg() << " bytes\n";
}

void decompressLZW(const string& inputFile) {
    ifstream inFile(inputFile, ios::binary);
    ofstream outFile("decompressed-LZW.txt", ios::binary);

    if (!inFile.is_open() || !outFile.is_open()) {
        cerr << "Error opening files!" << endl;
        return;
    }

    unordered_map<int, string> dictionary; // Инициализация обратного словаря, т.е. уже код -> строка
    for (int i = 0; i < 256; i++) {
        dictionary[i] = string(1, char(i));
    }

    int dictSize = 256; // Новые записи добавляются в словарь по мере обработки...
    int previousCode;
    inFile.read(reinterpret_cast<char*>(&previousCode), sizeof(previousCode));
    string current = dictionary[previousCode];
    outFile << current;

    int code;
    while (inFile.read(reinterpret_cast<char*>(&code), sizeof(code))) {
        string entry;
        if (dictionary.count(code)) {
            entry = dictionary[code];
        }
        else if (code == dictSize) {
            entry = current + current[0];
        }
        else {
            cerr << "Invalid LZW code: " << code << endl;
            break;
        }

        outFile << entry;

        if (dictSize < MAX_DICT_SIZE) {
            dictionary[dictSize++] = current + entry[0];
        }

        current = entry;
    }

    inFile.close();
    outFile.close();

    ifstream compressed(inputFile, ios::binary | ios::ate);
    ifstream decompressed("decompressed-LZW.txt", ios::binary | ios::ate);
    cout << "LZW decompression results:\n";
    cout << "Compressed size: " << compressed.tellg() << " bytes\n";
    cout << "Decompressed size: " << decompressed.tellg() << " bytes\n";
    cout << "Compression ratio: " << (1.0 - (double)compressed.tellg() / decompressed.tellg()) * 100 << "%\n";
}

// ----------------------------------- MTF [Move-To-Front] -----------------------------------

vector<unsigned char> mtfEncoder(const vector<unsigned char>& data) {
    list<int> symbol_list; // Список символов инициализировал
    for (int i = 0; i < 256; ++i) {
        symbol_list.push_back(i);
    }

    vector<unsigned char> encoded;
    for (unsigned char byte : data) {
        auto it = find(symbol_list.begin(), symbol_list.end(), byte); // Ищу текущий символ в списке
        int idx = distance(symbol_list.begin(), it); // Получаю его индекс
        encoded.push_back(static_cast<unsigned char>(idx)); // Добавляю индекс в выходные данные
        symbol_list.erase(it); // Перемещаю символ в начало списка
        symbol_list.push_front(byte);
    }
    return encoded;
}

vector<unsigned char> mtfDecoder(const vector<unsigned char>& data) {
    list<int> symbol_list; // Снова инициализация списка символов от 0 до 255
    for (int i = 0; i < 256; ++i) {
        symbol_list.push_back(i);
    }

    vector<unsigned char> decoded;
    for (unsigned char idx : data) {
        auto it = symbol_list.begin(); // Нахожу символ по индексу
        advance(it, idx); // Получаю доступ к индексу, увеличивая итератор на idx. O(n^2)
        unsigned char symbol = static_cast<unsigned char>(*it);
        decoded.push_back(symbol); // Добавляю в выходные и перемещаю в начало
        symbol_list.erase(it);
        symbol_list.push_front(symbol);
    }
    return decoded;
}

void compressMTF(const string& inputFile) {
    ifstream inFile(inputFile, ios::binary);
    if (!inFile) {
        cerr << "Error opening input file!" << endl;
        return;
    }

    vector<unsigned char> inputData((istreambuf_iterator<char>(inFile)),
        istreambuf_iterator<char>());
    inFile.close();

    vector<unsigned char> compressedData = mtfEncoder(inputData);

    ofstream outFile("compressed-MTF.bin", ios::binary);
    if (!outFile) {
        cerr << "Error creating output file!" << endl;
        return;
    }

    outFile.write(reinterpret_cast<const char*>(compressedData.data()), compressedData.size());
    outFile.close();

    ifstream original(inputFile, ios::binary | ios::ate);
    ifstream compressed("compressed-MTF.bin", ios::binary | ios::ate);
    cout << "MTF transform results:\n";
    cout << "Original size: " << original.tellg() << " bytes\n";
    cout << "Transformed size: " << compressed.tellg() << " bytes\n";
}

void decompressMTF(const string& inputFile) {
    ifstream inFile(inputFile, ios::binary);
    if (!inFile) {
        cerr << "Error opening input file!" << endl;
        return;
    }

    vector<unsigned char> compressedData((istreambuf_iterator<char>(inFile)),
        istreambuf_iterator<char>());
    inFile.close();

    vector<unsigned char> decompressedData = mtfDecoder(compressedData);

    ofstream outFile("decompressed-MTF.txt", ios::binary);
    if (!outFile) {
        cerr << "Error creating output file!" << endl;
        return;
    }

    outFile.write(reinterpret_cast<const char*>(decompressedData.data()), decompressedData.size());
    outFile.close();

    ifstream compressed(inputFile, ios::binary | ios::ate);
    ifstream decompressed("decompressed-MTF.txt", ios::binary | ios::ate);
    cout << "MTF inverse transform results:\n";
    cout << "Compressed size: " << compressed.tellg() << " bytes\n";
    cout << "Decompressed size: " << decompressed.tellg() << " bytes\n";
}

// ----------------------------------- LZ78 [Lempel-Ziv 1978] -----------------------------------

struct DictionaryKey {
    uint32_t parent_index; // Индекс родительской фразы в словаре
    uint8_t current_char;  // Текущий символ

    bool is_equal(const DictionaryKey& other) const { // Функция сравнения двух ключей для хеш-таблицы
        return parent_index == other.parent_index && current_char == other.current_char;
    }
};

struct DictionaryKeyHasher { // Создал хеш-функцию для DictionaryKey, чтобы использовать её в хеш-таблице
    size_t compute_hash(const DictionaryKey& k) const {
        size_t hash1 = hash<uint32_t>{}(k.parent_index); // Самые обычные хеш-функции для чисел
        size_t hash2 = hash<uint8_t>{}(k.current_char);

        return hash1 ^ (hash2 << 1); // Комбинирую хеши с помощью XOR и сдвига
    }
};

void write_uint32(uint32_t number, ostream& output_stream) { // Тот же формат, младшие байты сначала
    uint8_t bytes[4];
    bytes[0] = number & 0xFF;         // Младший байт
    bytes[1] = (number >> 8) & 0xFF;
    bytes[2] = (number >> 16) & 0xFF;
    bytes[3] = (number >> 24) & 0xFF; // Старший байт

    output_stream.write(reinterpret_cast<const char*>(bytes), 4);
}

uint32_t read_uint32(istream& input_stream) { // Читает 32-битное число из файла в формате little-endian
    uint8_t bytes[4];
    input_stream.read(reinterpret_cast<char*>(bytes), 4); // Читаю 4 байта

    if (input_stream.gcount() != 4) { // Прочитали ли мы все 4 байта
        throw runtime_error("Unexpected end of file");
    }

    return bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24); // Собираю число из 4 байтов
}

void compressLZ78(const string& input_filename) {
    string output_filename = "compressed-LZ78.bin";

    ifstream input_file(input_filename, ios::binary);
    if (!input_file) {
        throw runtime_error("Cannot open input file for compression");
    }

    ofstream output_file(output_filename, ios::binary);
    if (!output_file) {
        throw runtime_error("Cannot open output file for compression");
    }

    vector<uint8_t> file_data((istreambuf_iterator<char>(input_file)),
        istreambuf_iterator<char>());
    input_file.close();

    uint32_t file_size = file_data.size(); // Записал исходный размер файла
    write_uint32(file_size, output_file);

    unordered_map<DictionaryKey, uint32_t, DictionaryKeyHasher> dictionary; // Инициализация словаря
    uint32_t next_code = 1; // Следующий доступный код для новой фразы
    uint32_t current_code = 0; // Текущий код фразы

    for (uint8_t ch : file_data) { // Проходка по каждому символу в файле
        DictionaryKey key{ current_code, ch };

        auto found = dictionary.find(key); // Ищу фразу в словаре
        if (found != dictionary.end()) { // Если фраза есть в словаре, то продолжаем накапливать
            current_code = found->second;
        }
        else {
            write_uint32(current_code, output_file); // Если фраза новая, то записываю пару код символ
            output_file.put(ch);

            dictionary[key] = next_code++; // И добавляю в словарь
            current_code = 0; // Сбрасываю для новой фразы
        }
    }

    if (current_code != 0) { // Записываю оставшиеся данные, если они есть
        write_uint32(current_code, output_file);
        output_file.put(0);
    }

    output_file.close();
    cout << "File compressed successfully to " << output_filename << endl;
}

void decompressLZ78(const string& input_filename) {
    string output_filename = "decompressed-LZ78.txt";

    ifstream input_file(input_filename, ios::binary);
    if (!input_file) {
        throw runtime_error("Cannot open input file for decompression");
    }

    ofstream output_file(output_filename, ios::binary);
    if (!output_file) {
        throw runtime_error("Cannot open output file for decompression");
    }

    uint32_t original_size = read_uint32(input_file);

    vector<string> dictionary; // Инициализируем словарь с пустой строкой
    dictionary.push_back("");

    string decompressed_data;

    while (true) { // Читаю пары (код, символ). Соответственно пока файл не закончится
        uint32_t phrase_code;
        uint8_t character;

        try {
            phrase_code = read_uint32(input_file);
        }
        catch (const std::runtime_error& e) {
            if (input_file.eof()) break;
            throw;
        }

        character = input_file.get();
        if (input_file.eof()) break;

        if (phrase_code >= dictionary.size()) { // Проверил корректность кода
            throw runtime_error("Invalid index in compressed file");
        }

        string phrase = dictionary[phrase_code]; // Восстанавливаю фразу здесь
        phrase.push_back(static_cast<char>(character));

        decompressed_data += phrase; // Добавляю фразу к результату и в словарь
        dictionary.push_back(phrase);
    }

    if (decompressed_data.size() > original_size) { // Обрезаю до исходного размера на случай ошибок
        decompressed_data.resize(original_size);
    }

    output_file.write(decompressed_data.data(), decompressed_data.size());
    output_file.close();
    cout << "File decompressed successfully to " << output_filename << endl;
}

// ----------------------------------- New BWT [Burrows–Wheeler Transform - Suffix Array] -----------------------------------

vector<uint8_t> newBwtTransform(const vector<uint8_t>& block, int& index) {
    int n = block.size();
    if (n == 0) { // Соответственно проверка на целостность блока
        index = 0;
        return {};
    }

    vector<int> sa(n); // Создаю суффиксный массив
    iota(sa.begin(), sa.end(), 0);

    sort(sa.begin(), sa.end(), [&block, n](int a, int b) { // Сортирую суффиксы
        return lexicographical_compare( // a, b - это начальные позиции двух суффиксов
            block.begin() + a, block.end(), // Суффикс, начинающийся с позиции a
            block.begin() + b, block.end()); // и b соответственно
    });

    auto it = find(sa.begin(), sa.end(), 0); // Ищу позицию 0 индекса (начала исходной строки) в суффиксном массиве
    index = distance(sa.begin(), it); // Теперь можно найти расстояние от начала массива до этой позиции

    // Строим преобразование BWT
    vector<uint8_t> transformed;
    transformed.reserve(n);
    for (int i = 0; i < n; ++i) {
        int pos = sa[i] == 0 ? n - 1 : sa[i] - 1; // Если 0, то суффикс это вся строка. Если нет, то все остальные суффиксы
        transformed.push_back(block[pos]);
    }

    return transformed;
}

vector<uint8_t> newBwtInverse(const vector<uint8_t>& transformed, int index) {
    int n = transformed.size();
    if (n == 0) return {};

    // Создаем таблицу для обратного преобразования
    vector<pair<uint8_t, int>> table;
    table.reserve(n);
    for (int i = 0; i < n; ++i) {
        table.emplace_back(transformed[i], i);
    }

    stable_sort(table.begin(), table.end(),
        [](const pair<uint8_t, int>& a, const pair<uint8_t, int>& b) {
        return a.first < b.first;
    });

    vector<int> T(n); // Это таблица переходов
    for (int i = 0; i < n; ++i) {
        T[table[i].second] = i;
    }

    vector<uint8_t> original; // Восстанавил исходные данные
    original.reserve(n);
    int current = index;
    for (int i = 0; i < n; ++i) {
        original.push_back(transformed[current]);
        current = T[current];
    }

    reverse(original.begin(), original.end());
    return original;
}

void newCompressBWT(const string& input_file, int block_size = 10000000) {
    if (block_size <= 0) {
        throw invalid_argument("Block size must be positive");
    }

    ifstream input(input_file, ios::binary);
    ofstream output("compressed-newBWT.bin", ios::binary);

    if (!input) throw runtime_error("Cannot open input file: " + input_file);
    if (!output) throw runtime_error("Cannot open output file: compressed-BWT.bin");

    vector<uint8_t> block(block_size);

    while (true) {
        input.read(reinterpret_cast<char*>(block.data()), block_size);
        streamsize bytes_read = input.gcount();
        if (bytes_read == 0) break;

        // Создал копию блока с терминатором
        vector<uint8_t> block_with_sentinel(block.begin(), block.begin() + bytes_read);
        block_with_sentinel.push_back(0x00); // Добавляем терминатор

        int index;
        vector<uint8_t> transformed = newBwtTransform(block_with_sentinel, index);

        // Сохранил индекс и размер
        int32_t index32 = static_cast<int32_t>(index);
        int32_t size32 = static_cast<int32_t>(transformed.size());

        output.write(reinterpret_cast<const char*>(&index32), sizeof(index32));
        output.write(reinterpret_cast<const char*>(&size32), sizeof(size32));
        output.write(reinterpret_cast<const char*>(transformed.data()), transformed.size());
    }
}

void newDecompressBWT(const string& input_file) {
    ifstream input(input_file, ios::binary);
    ofstream output("decompressed-newBWT.txt", ios::binary);

    if (!input) throw runtime_error("Cannot open input file: " + input_file);
    if (!output) throw runtime_error("Cannot open output file: decompressed-newBWT.txt");

    input.seekg(0, ios::end);
    streampos compressed_size = input.tellg();
    input.seekg(0, ios::beg);
    cout << "Compressed file size: " << compressed_size << " bytes" << endl;

    while (true) {
        int32_t index32;
        input.read(reinterpret_cast<char*>(&index32), sizeof(index32));
        if (input.eof()) break;
        if (input.fail()) throw runtime_error("Failed to read block index");

        int32_t size32;
        input.read(reinterpret_cast<char*>(&size32), sizeof(size32));
        if (input.fail()) throw runtime_error("Failed to read block size");

        if (size32 <= 0) throw runtime_error("Invalid block size");

        vector<uint8_t> transformed(size32);
        input.read(reinterpret_cast<char*>(transformed.data()), size32);
        if (input.gcount() != size32) throw runtime_error("Truncated block data");

        vector<uint8_t> original_with_sentinel = newBwtInverse(transformed, index32);

        // Удаляем терминатор перед записью
        if (!original_with_sentinel.empty() && original_with_sentinel.back() == 0x00) {
            original_with_sentinel.pop_back();
        }

        output.write(reinterpret_cast<const char*>(original_with_sentinel.data()), original_with_sentinel.size());
        if (output.fail()) throw runtime_error("Failed to write decompressed data");
    }

    output.close();
    ifstream output_check("decompressed-newBWT.txt", ios::binary | ios::ate);
    cout << "Decompressed file size: " << output_check.tellg() << " bytes" << endl;
    output_check.close();
}

int main() {
    int choice;
    string inputFile;

    cout << "Select compression algorithm:\n";
    cout << "1. HA\n";
    cout << "2. BWT\n";
    cout << "3. MTF\n";
    cout << "4. RLE\n";
    cout << "5. LZ77\n";
    cout << "6. LZW\n";
    cout << "7. BWT + RLE\n";
    cout << "8. BWT + MTF + HA\n";
    cout << "9. BWT + MTF + RLE + HA\n";
    cout << "10. LZ77 + HA\n";
    cout << "11. LZW + HA\n";
    cout << "12. LZ78\n";
    cout << "13. LZ78 + HA\n";
    cout << "14. New BWT\n";
    cout << "Enter your choice: ";
    cin >> choice;

    cout << "Enter input file name: ";
    cin >> inputFile;

    switch (choice) {
    case 1:
        compressHA(inputFile);
        decompressHA("compressed-HA.bin");
        break;
    case 2:
        compressBWT(inputFile);
        decompressBWT("compressed-BWT.bin");
        break;
    case 3:
        compressMTF(inputFile);
        decompressMTF("compressed-MTF.bin");
        break;
    case 4:
        compressRLE(inputFile);
        decompressRLE("compressed-RLE.bin");
        break;
    case 5:
        compressLZ77(inputFile);
        decompressLZ77("compressed-LZ77.bin");
        break;
    case 6:
        compressLZW(inputFile);
        decompressLZW("compressed-LZW.bin");
        break;
    case 7:
        compressBWT(inputFile);
        compressRLE("compressed-BWT.bin");
        decompressRLE("compressed-RLE.bin");
        decompressBWT("decompressed-RLE.txt");
        break;
    case 8:
        compressBWT(inputFile);
        compressMTF("compressed-BWT.bin");
        compressHA("compressed-MTF.bin");
        decompressHA("compressed-HA.bin");
        decompressMTF("decompressed-HA.txt");
        decompressBWT("decompressed-MTF.txt");
        break;
    case 9:
        compressBWT(inputFile);
        compressMTF("compressed-BWT.bin");
        compressRLE("compressed-MTF.bin");
        compressHA("compressed-RLE.bin");
        decompressHA("compressed-HA.bin");
        decompressRLE("decompressed-HA.txt");
        decompressMTF("decompressed-RLE.txt");
        decompressBWT("decompressed-MTF.txt");
        break;
    case 10:
        compressLZ77(inputFile);
        compressHA("compressed-LZ77.bin");
        decompressHA("compressed-HA.bin");
        decompressLZ77("decompressed-HA.txt");
        break;
    case 11:
        compressLZW(inputFile);
        compressHA("compressed-LZW.bin");
        decompressHA("compressed-HA.bin");
        decompressLZW("decompressed-HA.txt");
        break;
    case 12:
        compressLZ78(inputFile);
        decompressLZ78("compressed-LZ78.bin"); 
        break;
    case 13:
        compressLZ78(inputFile);
        compressHA("compressed-LZ78.bin");
        decompressHA("compressed-HA.bin");
        decompressLZ78("decompressed-HA.txt");
        break;
    case 14:
        newCompressBWT(inputFile);
        newDecompressBWT("compressed-newBWT.bin");
        break;
    default:
        cout << "Invalid!\n";
    }

    return 0;
}
